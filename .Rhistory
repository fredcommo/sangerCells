return(output)
}
.generateGrps <- function(Mvector, Svector, n, p, grps = NULL, nGrp = 2, minP = 0.3, maxP = 0.8){
# Provide vector of means and coresspondong Sdev
# n, p : number of samples (provides if grps if not provided), number of probes, resp.
# minP, maxP : min and max proportion of samples in a grp for which a specif probe is generated.
# Returns a (p, n) matrix of probes specific to grps and the vector of grps as a list.
# if grps not provided, generate random grps according to nGrps
if(is.null(grps))
grps <- factor(rbinom(n, nGrp - 1, 0.5), labels = LETTERS[1:nGrp])
else if(!is.factor(grps)) grps <- as.factor(grps)
if(length(grps) != n) n <- length(grps)
nGrps <- nlevels(grps)
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
grp <- sample(levels(grps), 1)
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
# with respect to grps but some samples only, according to minP/maxP
idx <- sample(which(grps == grp))
rbi <- rbinom(length(idx), 1, prob = sample(seq(minP, maxP, by = 0.05), 1))
idx <- idx[rbi == 1]
change <- sample(c('inc', 'dec'), 1)
if(change == 'inc')
newmu <- min(max(MStable$M)*0.95, m*sample(seq(1.5, 2.5, by = 0.2), 1))
else
newmu <- max(min(MStable$M)*1.05, m/sample(seq(1.5, 2.5, by = 0.2), 1))
values[idx] <- rnorm(length(idx), newmu, .pickS(MStable, newmu))
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('signif', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(list(Data = output, Grps = grps))
}
################################################################
# dir.create('/Users/fredcommo/Documents/MyProjects/Simulations/ALLsimulation')
saveDir <- '/Users/fredcommo/Documents/MyProjects/Simulations/ALLsimulation/'
require(ALL)
data(ALL)
eset <- exprs(ALL)
samples <- pData(ALL)
M <- apply(eset, 1, mean, na.rm = TRUE)
S <- apply(eset, 1, sd, na.rm = TRUE)
trueDist <- .computeBounds(M, S)
factM <- factor(trueDist$M)
whiteProbes <- .generateRandom(M, S, ncol(eset), ceiling(nrow(eset)*0.1))
whiteM <- apply(whiteProbes, 1, mean, na.rm = TRUE)
whiteS <- apply(whiteProbes, 1, sd, na.rm = TRUE)
whiteProbesTable <- .computeBounds(whiteM, whiteS)
allType <- as.factor(ifelse(grepl('B', samples$BT), 'B', 'T'))
simulateGrps <- .generateGrps(M, S, n = ncol(eset), p = ceiling(nrow(eset)*0.01), grps = allType)
signifProbes <- simulateGrps$Data
signifM <- apply(signifProbes, 1, mean, na.rm = TRUE)
signifS <- apply(signifProbes, 1, sd, na.rm = TRUE)
signifProbesTable <- .computeBounds(signifM, signifS)
colnames(whiteProbes) <- colnames(signifProbes) <- colnames(eset)
#eset <- .insertRow(eset, whiteProbes, sample(1:nrow(eset), nrow(whiteProbes)))
#eset = kimData$eset
eset <- rbind(eset, whiteProbes, signifProbes)
randomIdx <- grep('random', rownames(eset))
signifIdx <- grep('signif', rownames(eset))
pcaProbes <- prcomp(eset)
require(multtest)
fullTest <- mt.maxT(eset, classlabel = factor(allType), B = 5000)
bestFull <- fullTest$index[fullTest$adjp<0.01 & !grepl('signif', rownames(fullTest))]
length(bestFull)
score <- pcaTrace(eset, pcaProbes, main = 'Information curve')
infos <- pcaInfo(score)
redDot = 10^(1/score$lModel$x.intercept)
select <- pcaSelect(score, redDot)
length(select)
filtTest <- mt.maxT(eset[select,], classlabel = factor(allType), B = 5000)
filtIndex <- filtTest$adjp<0.01 & !grepl('signif', rownames(filtTest))
any(grepl('random', rownames(filtTest)[filtIndex]))
bestFilt <- rownames(filtTest)[filtTest$adjp<0.01 & !grepl('signif', rownames(filtTest))]
bestFilt <- which(rownames(eset) %in% bestFilt)
length(bestFilt)
infos
select <- pcaSelect(score, 0.50)
length(select)
#Values <- t(eset[which(rownames(eset) %in% bestFilt),])
Values <- eset[select,]
dim(Values)
clust <- hclust(dist(t(Values)), 'ward')
plot(clust)
K = 7
cutClust <- cutree(clust, k = K)
clustTest <- mt.maxT(eset, classlabel = c(0:(K-1))[cutClust], test = 'f', B = 5000)
sum(clustTest$adjp < 0.001)/nrow(clustTest)
bestClust <- rownames(clustTest)[clustTest$adjp < 0.001]
length(bestClust)
Cols <- ifelse(grepl('random', rownames(eset)), 'red', ifelse(grepl('signif', rownames(eset)), 'blue', 'grey'))
Cols[bestFull] <- 'cyan'
Cols[bestFilt] <- 'steelblue3'
Cols[bestClust] <- 'seagreen4'
pairs(pcaProbes$x[,2:4], cex = 0.5, col = Cols)
pairs(pcaProbes$x[,2:4], pch = 19, cex = 0.5, col = Cols)
heatmap.3(t(Values),
# Colv = NA,
# dendrogram = "column",
scale = "column", Method = "ward",
col = colorpanel(100, "darkblue", 'grey95', "orange"),
breaks = seq(-2, 2, len = 101),
#rowsep = 0:(nrow(Values)), colsep = 1:(ncol(Values)-2), sepcolor = "grey85", sepwidth=c(0.001,0.001),
#cexRow = 1, labRow = NA,
RowSideColors = c('steelblue','seagreen','violet','indianred','purple','lightblue')[factor(cutClust)],
key = TRUE, keysize = 0.75, trace = "none", density.info = "none")
bestClust <- rownames(clustTest)[clustTest$adjp < 0.001]
bestClust <- which(rownames(eset) %in% bestClust)
length(bestClust)
Cols <- ifelse(grepl('random', rownames(eset)), 'red', ifelse(grepl('signif', rownames(eset)), 'blue', 'grey'))
Cols[bestFull] <- 'cyan'
Cols[bestFilt] <- 'steelblue3'
Cols[bestClust] <- 'seagreen4'
pairs(pcaProbes$x[,2:4], pch = 19, cex = 0.5, col = Cols)
table(Cols)
heatmap.3(t(eset[bestClust,]),
# Colv = NA,
# dendrogram = "column",
scale = "column", Method = "ward",
col = colorpanel(100, "darkblue", 'grey95', "orange"),
breaks = seq(-2, 2, len = 101),
#rowsep = 0:(nrow(Values)), colsep = 1:(ncol(Values)-2), sepcolor = "grey85", sepwidth=c(0.001,0.001),
#cexRow = 1, labRow = NA,
RowSideColors = c('steelblue','seagreen','violet','indianred','purple','lightblue')[factor(cutClust)],
key = TRUE, keysize = 0.75, trace = "none", density.info = "none")
table(cutClust, BT)
table(cutClust, allType)
head(samples)
table(cutClust, samples$sex)
table(cutClust, samples$BT)
table(cutClust, samples$remission)
table(cutClust, samples$CR)
table(cutClust, samples$t(4;11))
table(cutClust, samples$cyto.normal
)
table(cutClust, samples$citog)
table(cutClust, samples$mol.biol)
table(cutClust, samples$ccr)
table(cutClust, samples$relapse)
table(cutClust, samples$f.u)
table(cutClust, samples$cyto.normal)
table(cutClust, samples$CR)
table(cutClust, samples$BT)
Cols <- ifelse(grepl('random', rownames(eset)), 'red', ifelse(grepl('signif', rownames(eset)), 'blue', 'grey'))
Cols[bestFull] <- 'cyan'
Cols[bestFilt] <- 'steelblue3'
Cols[bestClust] <- 'seagreen4'
pairs(pcaProbes$x[,2:4], pch = 19, cex = 0.5, col = Cols)
Cols <- ifelse(grepl('random', rownames(eset)), 'red', ifelse(grepl('signif', rownames(eset)), 'blue', 'grey'))
Cols[bestFull] <- 'cyan'
Cols[bestFilt] <- 'steelblue3'
Cols[setdiff(bestClust, c(bestFull, bestFilt))] <- 'seagreen4'
pairs(pcaProbes$x[,2:4], pch = 19, cex = 0.5, col = Cols)
# Filtering on Kim Lung data
# Generates random probes by picking in the real probes, and randomly switch the samples
require(splines)
source('~/Fred_Scripts/pcaSelect.R')
source('~/Fred_Scripts/pcaInfo.R')
source('~/Fred_Scripts/pcaTrace.R')
source('~/Fred_Scripts/plotPCA.R')
op <- par(no.readonly = TRUE)
.computeBounds <- function(M, S){
mCuts <- cut(M, breaks = seq(min(M, na.rm = TRUE), max(M, na.rm = TRUE), by = 0.2)) #
labs <- levels(mCuts)
mBounds <- cbind.data.frame(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
mBounds$lower[1] <- min(M, na.rm = TRUE)
mBounds$upper[nrow(mBounds)] <- max(M, na.rm = TRUE)
mBounds <- cbind.data.frame(lower = mBounds$lower, med = (mBounds$upper + mBounds$lower)/2, upper = mBounds$upper)
sBounds <- lapply(seq(1, nrow(mBounds)), function(x){
index <- as.numeric(which(M >= mBounds$lower[x] & M < mBounds$upper[x]))
if(length(index)<1) cbind(S = NA, M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
else cbind(S = S[index], M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
})
sBounds <- do.call(rbind, sBounds)
rownames(sBounds) <- seq(1, nrow(sBounds))
return(as.data.frame(sBounds))
}
.dfunc <- function(x){
sbar <- sd(x, na.rm = TRUE)
mbar <- mean(x, na.rm = TRUE)
return(1/(sbar*sqrt(2*pi))*exp(-1/2*((x-mbar)/sbar)^2))
}
.pickM <- function(dM){
m = as.numeric(sample(dM$x, 1, prob = dM$y))
return(m)
}
# .pickS <- function(MStable, m){
#   j <- which(MStable$Ml <= m & MStable$Mu > m)
#   if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
#   else {
#     tmpS <- MStable$S[j]
# #    if(length(tmpS)>2){
# #      dS <- density(tmpS, na.rm = TRUE)
# #      s <- sample(dS$x[dS$x>0], 1, replace = FALSE)#, prob = pchisq(dS$x[dS$x>0], df = 1, ncp = m, lower.tail = FALSE))
#       s <- sample(tmpS, 1)#, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
# #    }
# #    else s <- sample(tmpS, 1)
#     }
#   return(s)
# }
.pickS <- function(MStable, m){
j <- which(MStable$Ml <= m & MStable$Mu > m)
#  if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
if(length(j)<1) {s <- min(MStable$S, na.rm = TRUE); cat('min S used for m:', m, '\n')}  else {
tmpS <- MStable$S[j]
if(length(tmpS)>2)
s <- sample(tmpS, 1, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
else s <- sample(tmpS, 1)
}
return(s)
}
.generateRandom <- function(Mvector, Svector, n, p){
# provide a vector of means and a vector of corresponding Sdev
# n samples, p probes
# returns a (p, n) matrix of random probes
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('random', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(output)
}
.generateGrps <- function(Mvector, Svector, n, p, grps = NULL, nGrp = 2, minP = 0.3, maxP = 0.8){
# Provide vector of means and coresspondong Sdev
# n, p : number of samples (provides if grps if not provided), number of probes, resp.
# minP, maxP : min and max proportion of samples in a grp for which a specif probe is generated.
# Returns a (p, n) matrix of probes specific to grps and the vector of grps as a list.
# if grps not provided, generate random grps according to nGrps
if(is.null(grps))
grps <- factor(rbinom(n, nGrp - 1, 0.5), labels = LETTERS[1:nGrp])
else if(!is.factor(grps)) grps <- as.factor(grps)
if(length(grps) != n) n <- length(grps)
nGrps <- nlevels(grps)
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
grp <- sample(levels(grps), 1)
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
# with respect to grps but some samples only, according to minP/maxP
idx <- sample(which(grps == grp))
rbi <- rbinom(length(idx), 1, prob = sample(seq(minP, maxP, by = 0.05), 1))
idx <- idx[rbi == 1]
change <- sample(c('inc', 'dec'), 1)
if(change == 'inc')
newmu <- min(max(MStable$M)*0.95, m*sample(seq(1.5, 2.5, by = 0.2), 1))
else
newmu <- max(min(MStable$M)*1.05, m/sample(seq(1.5, 2.5, by = 0.2), 1))
values[idx] <- rnorm(length(idx), newmu, .pickS(MStable, newmu))
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('signif', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(list(Data = output, Grps = grps))
}
require(splines)
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaSelect.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaInfo.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaTrace.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/plotPCA.R')
op <- par(no.readonly = TRUE)
.computeBounds <- function(M, S){
mCuts <- cut(M, breaks = seq(min(M, na.rm = TRUE), max(M, na.rm = TRUE), by = 0.2)) #
labs <- levels(mCuts)
mBounds <- cbind.data.frame(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
mBounds$lower[1] <- min(M, na.rm = TRUE)
mBounds$upper[nrow(mBounds)] <- max(M, na.rm = TRUE)
mBounds <- cbind.data.frame(lower = mBounds$lower, med = (mBounds$upper + mBounds$lower)/2, upper = mBounds$upper)
sBounds <- lapply(seq(1, nrow(mBounds)), function(x){
index <- as.numeric(which(M >= mBounds$lower[x] & M < mBounds$upper[x]))
if(length(index)<1) cbind(S = NA, M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
else cbind(S = S[index], M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
})
sBounds <- do.call(rbind, sBounds)
rownames(sBounds) <- seq(1, nrow(sBounds))
return(as.data.frame(sBounds))
}
.dfunc <- function(x){
sbar <- sd(x, na.rm = TRUE)
mbar <- mean(x, na.rm = TRUE)
return(1/(sbar*sqrt(2*pi))*exp(-1/2*((x-mbar)/sbar)^2))
}
.pickM <- function(dM){
m = as.numeric(sample(dM$x, 1, prob = dM$y))
return(m)
}
# .pickS <- function(MStable, m){
#   j <- which(MStable$Ml <= m & MStable$Mu > m)
#   if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
#   else {
#     tmpS <- MStable$S[j]
# #    if(length(tmpS)>2){
# #      dS <- density(tmpS, na.rm = TRUE)
# #      s <- sample(dS$x[dS$x>0], 1, replace = FALSE)#, prob = pchisq(dS$x[dS$x>0], df = 1, ncp = m, lower.tail = FALSE))
#       s <- sample(tmpS, 1)#, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
# #    }
# #    else s <- sample(tmpS, 1)
#     }
#   return(s)
# }
.pickS <- function(MStable, m){
j <- which(MStable$Ml <= m & MStable$Mu > m)
#  if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
if(length(j)<1) {s <- min(MStable$S, na.rm = TRUE); cat('min S used for m:', m, '\n')}  else {
tmpS <- MStable$S[j]
if(length(tmpS)>2)
s <- sample(tmpS, 1, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
else s <- sample(tmpS, 1)
}
return(s)
}
.generateRandom <- function(Mvector, Svector, n, p){
# provide a vector of means and a vector of corresponding Sdev
# n samples, p probes
# returns a (p, n) matrix of random probes
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('random', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(output)
}
.generateGrps <- function(Mvector, Svector, n, p, grps = NULL, nGrp = 2, minP = 0.3, maxP = 0.8){
# Provide vector of means and coresspondong Sdev
# n, p : number of samples (provides if grps if not provided), number of probes, resp.
# minP, maxP : min and max proportion of samples in a grp for which a specif probe is generated.
# Returns a (p, n) matrix of probes specific to grps and the vector of grps as a list.
# if grps not provided, generate random grps according to nGrps
if(is.null(grps))
grps <- factor(rbinom(n, nGrp - 1, 0.5), labels = LETTERS[1:nGrp])
else if(!is.factor(grps)) grps <- as.factor(grps)
if(length(grps) != n) n <- length(grps)
nGrps <- nlevels(grps)
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
grp <- sample(levels(grps), 1)
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
# with respect to grps but some samples only, according to minP/maxP
idx <- sample(which(grps == grp))
rbi <- rbinom(length(idx), 1, prob = sample(seq(minP, maxP, by = 0.05), 1))
idx <- idx[rbi == 1]
change <- sample(c('inc', 'dec'), 1)
if(change == 'inc')
newmu <- min(max(MStable$M)*0.95, m*sample(seq(1.5, 2.5, by = 0.2), 1))
else
newmu <- max(min(MStable$M)*1.05, m/sample(seq(1.5, 2.5, by = 0.2), 1))
values[idx] <- rnorm(length(idx), newmu, .pickS(MStable, newmu))
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('signif', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(list(Data = output, Grps = grps))
}
kimData = readRDS('/Users/fredcommo/Documents/MyProjects/Kim_Lung/kimData.rds')
eset = kimData$eset
samples <- kimData$samples
M <- apply(eset, 1, mean, na.rm = TRUE)
S <- apply(eset, 1, sd, na.rm = TRUE)
trueDist <- .computeBounds(M, S)
factM <- factor(trueDist$M)
whiteProbes <- lapply(seq(1, 2500), function(x){ if(x%%100 == 0) cat(x, '\t')
x <- sample(eset[sample(1, nrow(eset), 1),])
})
x <- eset[sample(1, nrow(eset), 1),]
sample(x, replace = TRUE)
x
x <- as.numeric(eset[sample(1, nrow(eset), 1),])
x <- as.numeric(eset[sample(1:nrow(eset), 1),])
x
sample(x, replace = TRUE)
whiteProbes <- lapply(seq(1, 100), function(x){ if(x%%100 == 0) cat(x, '\t')
x <- as.numeric(eset[sample(1:nrow(eset), 1),])
return(sample(x, replace = TRUE))
})
Samp <- sample(1:nrow(eset), 1000)
Samp <- sample(1:nrow(eset), 1000)
whiteProbes <- lapply(Samp, function(x){ if(x%%100 == 0) cat(x, '\t')
return(sample(as.numeric(eset[x,]), replace = TRUE))
})
Samp <- sample(1:nrow(eset), 2500)
whiteProbes <- lapply(Samp, function(x){return(sample(as.numeric(eset[x,]), replace = TRUE))})
whiteProbes <- do.call(rbind, whiteProbes)
rownames(whiteProbes) <- paste0('random', seq(1, nrow(whiteProbes)))
whiteM <- apply(whiteProbes, 1, mean, na.rm = TRUE)
whiteS <- apply(whiteProbes, 1, sd, na.rm = TRUE)
whiteProbesTable <- .computeBounds(whiteM, whiteS)
boxplot(log10(whiteProbesTable$S) ~ whiteProbesTable$M, names = round(unique(whiteProbesTable$M), 2),
outpch = 19, outcex = 0.25, col = 'steelblue2', outcol = 'steelblue4',
xlab = 'Means', ylab = 'Log10(Sdev)')
boxplot(log10(whiteProbesTable$S) ~ whiteProbesTable$M,
outpch = 19, outcex = 0.25, col = 'steelblue2', outcol = 'steelblue4',
xlab = 'Means', ylab = 'Log10(Sdev)')
head(samples)
q()
projectId <- "syn1834040"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
fileHandleId <- file@fileHandle$id
fileWikiUri <- sprintf("/entity/%s/wiki", propertyValue(file, "id"))
require(synapseClient)
synapseLogin('frederic.commo@sagebase.org', 'Se@ttle7')
projectId <- "syn1834040"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
file
properties(getEntity(projectId))
file <- synStore(file)
file <- storeEntity(file)
projectId <- "syn1834037"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
file
file <- storeEntity(file)
e <- getEntity('syn1834040')
e@fileHandle$id
file <- storeEntity(file)
traceback()
file<-synStore(file)
traceback()
rm(file)
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt_2.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
fileHandleId <- file@fileHandle$id
fileWikiUri <- sprintf("/entity/%s/wiki", propertyValue(file, "id"))
# we start a wiki
fileWiki<-list()
# we add to our wiki the ID of the previously uploaded file
fileWiki$attachmentFileHandleIds<-list(fileHandleId)
# in the markdown we say to display the image.  Note, 'fileName' is the URLEncoded version of the file chosen above.
fileWiki$markdown<-"${image?fileName=mygraph%2Epng}"
# now 'push' the wiki to Synapse
fileWiki<-synRestPOST(fileWikiUri, fileWiki)
# voila!
onWeb(propertyValue(file, "id"))
require(synapseClient)
require(affy)
synapseLogin()
q()
source('http://depot.sagebase.org/CRAN.R')
pkgInstall("synapseClient")
q()
require(synapseClient)
synapseLogin()
e <- loadEntity('syn1855799')
load(file.path(e$cacheDir, e$files))
sangerCells
e <- loadEntity('syn1855802')
e
source(file.path(e$cacheDir, e$files))
methods("show")
e <- loadEntity('syn1855802')
source(file.path(e$cacheDir, e$files))
source('./cellLinesObjClass.R')
setwd('/Users/fredcommo/Documents/MyProjects/CellLines/SangerCells/')
source('./cellLinesObjClass.R')
e <- loadEntity('syn1855802')
source(file.path(e$cacheDir, e$files))
e <- loadEntity('syn1855799')
load(file.path(e$cacheDir, e$files))
sangerCells
q()
